BUSINESS CLASSES
================

Business classes must be descendants of the TPressObject class. Business class 
attributes are registered through its metadata, see the file 'Metadata.txt' 
for more information about creating class metadata. If an attribute needs to 
be referenced elsewhere in code, attribute pointers can be created. While not 
mandatory, as the inherited AttributeByName method can be used, attribute 
pointers provide a faster and less error prone way to reference attributes.

Creating attribute pointers
---------------------------

There are two ways to create an attribute pointer inside the business class. 
The first one is by creating the attribute in the initial, unnamed section of 
the class and adding an underscore "_" prefix to the attribute name (As the 
TPressObject class is a descendant of TPersistent it has RTTI enabled, so the 
initial, unnamed section is published).

TClient = class(TPressObject)
  _Name: TPressString;
protected
  class function InternalMetadataStr: string; override;
end;

An attribute, named "Name", declared as String, will be referenced by the 
_Name member of a TClient instance.

The second approach is:

TClient = class(TPressObject)
private
  FName: TPressString;
protected
  function InternalAttributeAddress(const AAttributeName: string): 
   PPressAttribute; override;
  class function InternalMetadataStr: string; override;
end;

...

function TClient.InternalAttributeAddress(const AAttributeName: string): 
  PPressAttribute;
begin
  if SameText(AAttributeName, 'Name') then
    Result := Addr(FName)
  else
    Result := inherited InternalAttributeAddress(AAttributeName);
end;

This approach generates more code but won't break the encapsulation.

Using member accessor properties
--------------------------------

Attribute accessors are Business class properties with native types of the 
compiler. They provide easier access to attribute values. The PressObjects' 
subject framework will look for published properties with the same name as its 
attributes.

TClient = class(TPressObject)
  _Name: TPressString;
private
  function GetName: string;
  procedure SetName(const AValue: string);
protected
  class function InternalMetadataStr: string;
published
  property Name: string read GetName write SetName;
end;

In this example, whenever the Name attribute is fetched by the internals of the 
framework, the GetName method is called. Similarly the SetName method is 
called whenever the Name attribute is changed. If the getter, setter or the 
whole property isn't declared or isn't published, the framework will fetch or 
change the attribute directly.

The following list recommends the PressObjects attribute classes to use as 
public or published properties for respective application data types:

TPressString     = string
TPressInteger    = Integer
TPressFloat      = Double
TPressCurrency   = Currency
TPressEnum       = Enum declared and registered by the user
TPressBoolean    = Boolean
TPressDate       = TDate
TPressTime       = TTime
TPressDateTime   = TDateTime
TPressMemo       = string
TPressPicture    = (not implemented)
TPressBinary     = no recommendation, it is generally used for streaming
TPressPart and
TPressReference  = the business class which the attribute is referencing
TPressParts and
TPressReferences = the attribute itself or a user registered attribute

Note: using the Parts and References attributes in the published section has 
no effect.

User defined attributes
-----------------------

To create a customized attribute, declare a new class that inherits from a 
TPressAttribute descendant, override the AttributeName method to declare its 
name (mandatory for all attribute classes, except TPressParts and 
TPressReferences) and register it by calling its RegisterAttribute method in 
the initialization section of the unit:

initialization
  TZipCodeString.RegisterAttribute;

Query classes
-------------

A query is a business class whose instances are used to retrieve objects 
without knowing their IDs. Queries are descendants of TPressQuery.

The attributes of a query are used to filter data.

TClientQuery = class(TPressQuery)
  _Name: TPressString;
private
  function GetName: string;
  procedure SetName(const AValue: string);
protected
  class function InternalMetadataStr: string; override;
published
  property Name: string read GetName write SetName;
end;

When executed, this query will match client objects based on the Name 
attribute. See the file Metadata.txt for details about the match types.

Registering Business Classes
----------------------------

To register a business class, call the following method from the 
initialization section of the unit where the business class is declared:

initialization
  TClient.RegisterClass;

Registering Enumerations
------------------------

PressObjects supports Enum attributes. To create an enumeration and register 
it, use:

PressModel.PressRegisterEnumMetadata(TypeInfo(<EnumName>), '<EnumNameString>', 
 ['<FirstItemStr>', '<SecondItemStr>', ...]);

<EnumName> = name of enumeration for the compiler (how it was declared)

<EnumNameString> = name of the enumeration for the framework. To avoid 
confusion, it is highly recommended that the same enumeration name is used for 
both compiler and framework.

<FirstItemStr>, <SecondItemStr> = Items of an open array that holds the 
string representation of each enum item. Optional. If missed out, a formatted 
version of the enum item name is used.
